\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}

\begin{document}

\section*{Сборка и объектные файлы}

\begin{enumerate}
    \item \textbf{Соберtv программу}, чтобы увидеть, что на каждый \texttt{*.cpp} файл создаётся отдельный объектный файл. Для Visual Studio это будут файлы с расширением \texttt{*.obj}, и они будут созданы в папке Debug.

    \item \textbf{Убедимся, что при изменении одного \texttt{*.cpp} файла и пересборке проекта обновляется только соответствующий ему объектный файл.} Для этого изменим код в \texttt{module1.cpp} или \texttt{module2.cpp}, пересоберем проект и проверим даты изменения объектных файлов.
\end{enumerate}

\section*{Вывод программы}

\begin{enumerate}
    \setcounter{enumi}{2}
    \item \textbf{Объяснение строк (A) и (D) в \texttt{main.cpp}:}

    \begin{itemize}
        \item \textbf{(A)}
        \begin{lstlisting}[language=C++]
std::cout << getMyName() << "\n"; // (A)
        \end{lstlisting}
        Так как перед этой строкой было заключено \lstinline|using namespace Module1;|, выполнится функция \lstinline|Module1::getMyName()|, которая вернет "John".

        \item (D)
        \begin{lstlisting}[language=C++]
using Module2::getMyName;
std::cout << getMyName() << "\n"; // (D)
        \end{lstlisting}
        Здесь объявлено \lstinline|using Module2::getMyName;|, поэтому вызывается функция \lstinline|Module2::getMyName()|, которая вернет "James".
    \end{itemize}
\end{enumerate}

\section*{Ошибки компиляции}

\begin{enumerate}
    \setcounter{enumi}{3}
    \item Раскомментируем строки (B) и (C):
    \begin{lstlisting}[language=C++]
using namespace Module2; // (B)
std::cout << getMyName() << "\n"; // COMPILATION ERROR (C)
    \end{lstlisting}

    Это приведет к ошибке компиляции. Ошибка происходит из-за неоднозначности вызова функции \lstinline|getMyName()|, не ясно, использовать \lstinline|Module1::getMyName| или \lstinline|Module2::getMyName|.

    Решение:
    \begin{itemize}
        \item Указывать, какую именно функцию вызывать:
        \begin{lstlisting}[language=C++]
std::cout << Module1::getMyName() << "\n";
std::cout << Module2::getMyName() << "\n";
        \end{lstlisting}
    \end{itemize}
\end{enumerate}

\section*{Добавление новой функции}

\begin{enumerate}
    \setcounter{enumi}{4}
    \item Добавим новую функцию \lstinline|getMyName()| в еще одном пространстве имен:

    Создадим файлы \texttt{module3.h} и \texttt{module3.cpp}.

    \textbf{File module3.h:}
    \begin{lstlisting}[language=C++]
#include <string>

namespace Module3
{
  std::string getMyName();
}
    \end{lstlisting}

    \textbf{File module3.cpp:}
    \begin{lstlisting}[language=C++]
#include "module3.h"

namespace Module3
{
  std::string getMyName()
  {
    return "Peter";
  }
}
    \end{lstlisting}

    Изменим \texttt{main.cpp} для вызова новой функции:
    \begin{lstlisting}[language=C++]
#include "module1.h"
#include "module2.h"
#include "module3.h"
#include <iostream>

int main(int argc, char** argv)
{
  std::cout << "Hello world!" << "\n";

  std::cout << Module1::getMyName() << "\n";
  std::cout << Module2::getMyName() << "\n";

  using namespace Module1;
  std::cout << getMyName() << "\n"; // (A)
  std::cout << Module2::getMyName() << "\n";

  //using namespace Module2; // (B)
  //std::cout << getMyName() << "\n"; // COMPILATION ERROR (C)

  using Module2::getMyName;
  std::cout << getMyName() << "\n"; // (D)

  std::cout << Module3::getMyName() << "\n";
}
    \end{lstlisting}
\end{enumerate}

\section*{Избавление от \texttt{std::cout}}

\begin{enumerate}
    \setcounter{enumi}{5}
    \item Чтобы избавиться от необходимости писать \texttt{std::cout}, можно использовать конструкцию using namespace std:
    \begin{lstlisting}[language=C++]
#include <iostream>

using namespace std;

int main()
{
  cout << "Hello world!" << endl;
  return 0;
}
    \end{lstlisting}

    Таким образом, можно использовать \texttt{cout} и \texttt{endl} без префикса \texttt{std::}.
\end{enumerate}

\end{document}
